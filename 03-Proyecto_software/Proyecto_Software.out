\BOOKMARK [0][-]{chapter.1}{Herramientas}{}% 1
\BOOKMARK [1][-]{section.1.1}{Editor, compilador \(``compiler''\) y enlazador \(``linker''\)}{chapter.1}% 2
\BOOKMARK [1][-]{section.1.2}{Automatizaci\363n del proceso de compilaci\363n}{chapter.1}% 3
\BOOKMARK [1][-]{section.1.3}{El compilador es tu mejor aliado,... si le permites supervisar el c\363digo.}{chapter.1}% 4
\BOOKMARK [1][-]{section.1.4}{El tratamiento de excepciones tambi\351n es tu aliado,... si no lo usas para enterrar la cabeza bajo el suelo e ignorar las excepciones.}{chapter.1}% 5
\BOOKMARK [1][-]{section.1.5}{Depurador \(``debugger''\)}{chapter.1}% 6
\BOOKMARK [1][-]{section.1.6}{Marco de ejecuci\363n de pruebas\(``test framework''\)}{chapter.1}% 7
\BOOKMARK [1][-]{section.1.7}{Gestor de versiones \(``version control''\)}{chapter.1}% 8
\BOOKMARK [1][-]{section.1.8}{La documentaci\363n del sistema}{chapter.1}% 9
\BOOKMARK [1][-]{section.1.9}{Comprobador est\341tico de c\363digo \(``linter''\)}{chapter.1}% 10
\BOOKMARK [1][-]{section.1.10}{Analizador de rendimiento \(``profiler''\)}{chapter.1}% 11
\BOOKMARK [1][-]{section.1.11}{Automatizaci\363n de todo el proceso:estrat\351gias ``CI/CD'' y enfoque ``DevOps''}{chapter.1}% 12
\BOOKMARK [0][-]{chapter.2}{Organizaci\363n: gesti\363n de proyectos}{}% 13
\BOOKMARK [1][-]{section.2.1}{Requisitos y tareas: funcionalidades a implementar}{chapter.2}% 14
\BOOKMARK [1][-]{section.2.2}{Estimaci\363n de lo que supone cada requisito o tarea}{chapter.2}% 15
\BOOKMARK [2][-]{subsection.2.2.1}{coste de implementaci\363n}{section.2.2}% 16
\BOOKMARK [2][-]{subsection.2.2.2}{valor aportado al cliente}{section.2.2}% 17
\BOOKMARK [1][-]{section.2.3}{Prioridades: en qu\351 orden abordar los trabajos}{chapter.2}% 18
\BOOKMARK [1][-]{section.2.4}{Secuenciaci\363n de tareas}{chapter.2}% 19
\BOOKMARK [1][-]{section.2.5}{Seguimiento del progreso}{chapter.2}% 20
\BOOKMARK [2][-]{subsection.2.5.1}{control de recursos consumidos}{section.2.5}% 21
\BOOKMARK [2][-]{subsection.2.5.2}{difusi\363n de informaci\363n}{section.2.5}% 22
\BOOKMARK [0][-]{chapter.3}{Paradigmas y lenguajes de programaci\363n}{}% 23
\BOOKMARK [1][-]{section.3.1}{Imperativo/procedural : m\341quina}{chapter.3}% 24
\BOOKMARK [1][-]{section.3.2}{Imperativo/procedural : estructurado}{chapter.3}% 25
\BOOKMARK [1][-]{section.3.3}{Orientado a objeto}{chapter.3}% 26
\BOOKMARK [1][-]{section.3.4}{Funcional}{chapter.3}% 27
\BOOKMARK [0][-]{chapter.4}{Arquitecturas de software}{}% 28
\BOOKMARK [1][-]{section.4.1}{Monol\355tico}{chapter.4}% 29
\BOOKMARK [1][-]{section.4.2}{Desktop, ``de escritorio''}{chapter.4}% 30
\BOOKMARK [1][-]{section.4.3}{Cliente/Servidor}{chapter.4}% 31
\BOOKMARK [1][-]{section.4.4}{Servicios distribuidos}{chapter.4}% 32
\BOOKMARK [0][-]{chapter.5}{Patrones de programaci\363n \(patterns\)}{}% 33
\BOOKMARK [1][-]{section.5.1}{Rationale, el por qu\351 de los patrones}{chapter.5}% 34
\BOOKMARK [1][-]{section.5.2}{Ejemplos de algunos patrones}{chapter.5}% 35
\BOOKMARK [2][-]{subsection.5.2.1}{observer}{section.5.2}% 36
\BOOKMARK [2][-]{subsection.5.2.2}{chain of responsibility}{section.5.2}% 37
\BOOKMARK [2][-]{subsection.5.2.3}{command}{section.5.2}% 38
\BOOKMARK [2][-]{subsection.5.2.4}{memento}{section.5.2}% 39
\BOOKMARK [2][-]{subsection.5.2.5}{adapter}{section.5.2}% 40
\BOOKMARK [2][-]{subsection.5.2.6}{decorator}{section.5.2}% 41
\BOOKMARK [2][-]{subsection.5.2.7}{facade}{section.5.2}% 42
\BOOKMARK [2][-]{subsection.5.2.8}{proxy}{section.5.2}% 43
\BOOKMARK [0][-]{chapter.6}{Algoritmos}{}% 44
\BOOKMARK [1][-]{section.6.1}{Ordenaci\363n, clasificaci\363n y b\372squeda}{chapter.6}% 45
\BOOKMARK [2][-]{subsection.6.1.1}{b\372squedas directas}{section.6.1}% 46
\BOOKMARK [2][-]{subsection.6.1.2}{estructuraci\363n arb\363rea}{section.6.1}% 47
\BOOKMARK [2][-]{subsection.6.1.3}{estructuraci\363n indexada}{section.6.1}% 48
\BOOKMARK [2][-]{subsection.6.1.4}{estructuraci\363n sem\341ntica}{section.6.1}% 49
\BOOKMARK [1][-]{section.6.2}{C\341lculo num\351rico o simb\363lico}{chapter.6}% 50
\BOOKMARK [2][-]{subsection.6.2.1}{ecuaciones lineales}{section.6.2}% 51
\BOOKMARK [2][-]{subsection.6.2.2}{derivaci\363n e integraci\363n}{section.6.2}% 52
\BOOKMARK [2][-]{subsection.6.2.3}{series de Taylor}{section.6.2}% 53
\BOOKMARK [2][-]{subsection.6.2.4}{transformadas de Fourier}{section.6.2}% 54
\BOOKMARK [1][-]{section.6.3}{Optimizaci\363n, programaci\363n lineal}{chapter.6}% 55
\BOOKMARK [1][-]{section.6.4}{Combinatorios}{chapter.6}% 56
\BOOKMARK [2][-]{subsection.6.4.1}{b\372squeda por ``fuerza bruta''}{section.6.4}% 57
\BOOKMARK [2][-]{subsection.6.4.2}{b\372squedas reducidas, en profundidad o en anchura}{section.6.4}% 58
\BOOKMARK [2][-]{subsection.6.4.3}{heur\355sticas}{section.6.4}% 59
\BOOKMARK [2][-]{subsection.6.4.4}{m\351todos de Montecarlo}{section.6.4}% 60
\BOOKMARK [1][-]{section.6.5}{Algoritmos que aprenden}{chapter.6}% 61
\BOOKMARK [1][-]{section.6.6}{Algoritmos que evolucionan}{chapter.6}% 62
\BOOKMARK [0][-]{chapter.7}{\277Gigantes\203? o \277Molinos?\203}{}% 63
\BOOKMARK [1][-]{section.7.1}{c\363mo nombrar las variables ?!?}{chapter.7}% 64
\BOOKMARK [1][-]{section.7.2}{c\363mo abrir-cerrar bloques ?!?}{chapter.7}% 65
\BOOKMARK [1][-]{section.7.3}{qu\351 usar para la indentaci\363n: tabuladores ?!? o espacios ?!? }{chapter.7}% 66
\BOOKMARK [1][-]{section.7.4}{longitud de nombres para variables y funciones ?!?}{chapter.7}% 67
\BOOKMARK [1][-]{section.7.5}{usar documentaci\363n/comentarios externos o hacer que el propio c\363digo sea claro de leer ?!?}{chapter.7}% 68
\BOOKMARK [1][-]{section.7.6}{Un consejo:}{chapter.7}% 69
\BOOKMARK [0][-]{chapter.8}{Algunos conceptos importantes para obtener software de calidad}{}% 70
\BOOKMARK [1][-]{section.8.1}{GIGO, la calidad en los datos es importante}{chapter.8}% 71
\BOOKMARK [1][-]{section.8.2}{KISS, cuanto m\341s simple, menos problemas}{chapter.8}% 72
\BOOKMARK [1][-]{section.8.3}{YAGNI, flexibilidad para evolucionar}{chapter.8}% 73
\BOOKMARK [1][-]{section.8.4}{Divide y vencer\341s}{chapter.8}% 74
\BOOKMARK [1][-]{section.8.5}{Arquitecturas multi-capa}{chapter.8}% 75
\BOOKMARK [1][-]{section.8.6}{SOLID, responsabilidades claras, cada parte hace lo suyo, y lo hace bien}{chapter.8}% 76
\BOOKMARK [2][-]{subsection.8.6.1}{SRP \(Single Responsibility Principle\)}{section.8.6}% 77
\BOOKMARK [2][-]{subsection.8.6.2}{OCP \(Open Close Principle\)}{section.8.6}% 78
\BOOKMARK [2][-]{subsection.8.6.3}{LSP \(Liskov Substitution Principle\)}{section.8.6}% 79
\BOOKMARK [2][-]{subsection.8.6.4}{ISP \(Interface Segregation Principle\)}{section.8.6}% 80
\BOOKMARK [2][-]{subsection.8.6.5}{DIP \(Dependency Inversion Principle\)}{section.8.6}% 81
\BOOKMARK [1][-]{section.8.7}{IDEALS, responsabilidades claras, cada parte hace lo suyo, y lo hace bien}{chapter.8}% 82
\BOOKMARK [2][-]{subsection.8.7.1}{Interface segregation}{section.8.7}% 83
\BOOKMARK [2][-]{subsection.8.7.2}{Deployability}{section.8.7}% 84
\BOOKMARK [2][-]{subsection.8.7.3}{Event-driven}{section.8.7}% 85
\BOOKMARK [2][-]{subsection.8.7.4}{Availability over consistency}{section.8.7}% 86
\BOOKMARK [2][-]{subsection.8.7.5}{Loose-coupling}{section.8.7}% 87
\BOOKMARK [2][-]{subsection.8.7.6}{Single responsibility}{section.8.7}% 88
\BOOKMARK [0][-]{chapter.9}{Sugerencias desde la cocina, algunas ideas pr\341cticas}{}% 89
\BOOKMARK [1][-]{section.9.1}{La importancia de refactorizar}{chapter.9}% 90
\BOOKMARK [2][-]{subsection.9.1.1}{rationale tras la refactorizaci\363n}{section.9.1}% 91
\BOOKMARK [2][-]{subsection.9.1.2}{disponer de una red de seguridad, facilita la refactorizaci\363n}{section.9.1}% 92
\BOOKMARK [1][-]{section.9.2}{La importancia de los tests internos}{chapter.9}% 93
\BOOKMARK [1][-]{section.9.3}{La forma natural de construir software es construirlo de forma iterativa}{chapter.9}% 94
\BOOKMARK [1][-]{section.9.4}{Cuando utilices un estandar o paradigma conocido\203}{chapter.9}% 95
\BOOKMARK [1][-]{section.9.5}{Realizar ``Hello, world''s para aprender}{chapter.9}% 96
\BOOKMARK [1][-]{section.9.6}{N\372meros, Fechas y otras hierbas similares: cada cual las escribe diferente}{chapter.9}% 97
\BOOKMARK [1][-]{section.9.7}{Magnitudes: n\372meros con unidad de medida}{chapter.9}% 98
\BOOKMARK [1][-]{section.9.8}{C\363digos: identificar elementos}{chapter.9}% 99
\BOOKMARK [2][-]{subsection.9.8.1}{Una nota hist\363rica:}{section.9.8}% 100
\BOOKMARK [2][-]{subsection.9.8.2}{Algunos consejos:}{section.9.8}% 101
\BOOKMARK [2][-]{subsection.9.8.3}{A tener en cuenta cuando haya varias partes que asignan codigos de forma distribuida}{section.9.8}% 102
\BOOKMARK [2][-]{subsection.9.8.4}{Algunas reflexiones acerca de la cantidad de c\363digos posibles:}{section.9.8}% 103
\BOOKMARK [2][-]{subsection.9.8.5}{El uso de UUIDs como identificadores internos de elementos}{section.9.8}% 104
\BOOKMARK [1][-]{section.9.9}{Un truco muy \372til: identificadores internos solo para uso interno e identificadores externos solo para uso externo}{chapter.9}% 105
\BOOKMARK [1][-]{section.9.10}{Un truco muy \372til: inactivar elementos en vez de borrarlos}{chapter.9}% 106
\BOOKMARK [1][-]{section.9.11}{Una forma de recoger especificaciones: BDD \(Behavior Driven Development\)}{chapter.9}% 107
\BOOKMARK [1][-]{section.9.12}{Una reflexi\363n acerca de las ventajas de manejar datos inmutables}{chapter.9}% 108
\BOOKMARK [1][-]{section.9.13}{Una reflexi\363n personal acerca de poner controles en el programa para evitar ``errores de usuario''}{chapter.9}% 109
\BOOKMARK [0][-]{chapter.10}{ap\351ndice: algo de bibliografia}{}% 110
\BOOKMARK [1][-]{section.10.1}{notas hist\363ricas: para situarnos en los distintos marcos temporales}{chapter.10}% 111
\BOOKMARK [1][-]{section.10.2}{Mis libros favoritos}{chapter.10}% 112
\BOOKMARK [1][-]{section.10.3}{Otros libros, documentos, referencias,\203}{chapter.10}% 113
